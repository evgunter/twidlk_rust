// this is a port of
// https://github.com/edanaher/twidlk/blob/master/src/Main.hs
// base generated by Claude 3.5 Sonnet (but i fixed the bugs, improved the error handling, and added the fancy stuff with macros)

// licensed under GPLv3

// === Data ===

use lazy_static::lazy_static;

use std::collections::HashMap;
use std::fs;
use std::path::Path;
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use std::io::{Read, Cursor};
use std::fmt::Write;
use std::error::Error;
use strum::VariantArray;
use strum_macros::VariantArray;


#[derive(Debug)]
pub struct TwiddlerConfig {
    pub version: (),
    pub key_repeat: bool,
    pub direct_key: bool,
    pub joystick_left_click: bool,
    pub disable_bluetooth: bool,
    pub sticky_num: bool,
    pub sticky_shift: bool,
    pub haptic_feedback: bool,

    pub sleep_timeout: u16,
    pub mouse_left_click_action: u16,
    pub mouse_middle_click_action: u16,
    pub mouse_right_click_action: u16,
    pub mouse_accel_factor: u8,
    pub key_repeat_delay: u8,

    pub chords: Vec<RawChord>,
}

impl TwiddlerConfig {
    fn default() -> Self {
        TwiddlerConfig {
            version: (),
            key_repeat: false,
            direct_key: false,
            joystick_left_click: true,
            disable_bluetooth: false,
            sticky_num: false,
            sticky_shift: false,
            haptic_feedback: false,

            sleep_timeout: 1500,
            mouse_left_click_action: 0,
            mouse_middle_click_action: 0,
            mouse_right_click_action: 0,
            mouse_accel_factor: 10,
            key_repeat_delay: 100,

            chords: Vec::new(),
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ChordOutput {
    SingleChord { modifier: u8, key_code: u8 },
    MultipleChordIndex { string_index: u8 },
    MultipleChord(Vec<ChordOutput>),
}

#[derive(Debug)]
pub struct RawChord {
    pub keys: Vec<u16>,
    pub output: ChordOutput,
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum Shifted {
    Shifted,
    Unshifted,
    ShiftAgnostic,
}

pub type UsbHidKey = (Shifted, u8);
pub type UsbHidValue = (Shifted, String);

lazy_static! {
    pub static ref USB_HID_TABLE: Vec<(UsbHidKey, UsbHidValue)> = {
        let mut table = Vec::new();

        // Lowercase letters
        table.extend((0x04..=0x1d).map(|n| {
            ((Shifted::Unshifted, n), (Shifted::Unshifted, String::from((n - 0x04 + b'a') as char)))
        }));

        // Uppercase letters
        table.extend((0x04..=0x1d).map(|n| {
            ((Shifted::Shifted, n), (Shifted::Unshifted, String::from((n - 0x04 + b'A') as char)))
        }));

        // Numbers
        table.extend((0x1e..=0x26).map(|n| {
            ((Shifted::Unshifted, n), (Shifted::Unshifted, String::from((n - 0x1e + b'1') as char)))
        }));

        // Zero
        table.push(((Shifted::Unshifted, 0x27), (Shifted::Unshifted, "0".to_string())));

        // Function keys
        table.extend((0x3a..=0x45).map(|n| {
            ((Shifted::ShiftAgnostic, n), (Shifted::ShiftAgnostic, format!("<F{}>", n - 0x39)))
        }));

        // Special characters
        table.extend(vec![
            ((Shifted::Shifted, 0x1e), (Shifted::Unshifted, "!".to_string())),
            ((Shifted::Shifted, 0x1f), (Shifted::Unshifted, "@".to_string())),
            ((Shifted::Shifted, 0x20), (Shifted::Unshifted, "#".to_string())),
            ((Shifted::Shifted, 0x21), (Shifted::Unshifted, "$".to_string())),
            ((Shifted::Shifted, 0x22), (Shifted::Unshifted, "%".to_string())),
            ((Shifted::Shifted, 0x23), (Shifted::Unshifted, "^".to_string())),
            ((Shifted::Shifted, 0x24), (Shifted::Unshifted, "&".to_string())),
            ((Shifted::Shifted, 0x25), (Shifted::Unshifted, "*".to_string())),
            ((Shifted::Shifted, 0x26), (Shifted::Unshifted, "(".to_string())),
            ((Shifted::Shifted, 0x27), (Shifted::Unshifted, ")".to_string())),
            ((Shifted::ShiftAgnostic, 0x28), (Shifted::ShiftAgnostic, "<return>".to_string())),
            ((Shifted::ShiftAgnostic, 0x29), (Shifted::ShiftAgnostic, "<escape>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2a), (Shifted::ShiftAgnostic, "<backspace>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2b), (Shifted::ShiftAgnostic, "<tab>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2c), (Shifted::ShiftAgnostic, "<space>".to_string())),
            ((Shifted::Unshifted, 0x2d), (Shifted::Unshifted, "-".to_string())),
            ((Shifted::Shifted, 0x2d), (Shifted::Unshifted, "_".to_string())),
            ((Shifted::Unshifted, 0x2e), (Shifted::Unshifted, "=".to_string())),
            ((Shifted::Shifted, 0x2e), (Shifted::Unshifted, "+".to_string())),
            ((Shifted::Unshifted, 0x2f), (Shifted::Unshifted, "[".to_string())),
            ((Shifted::Shifted, 0x2f), (Shifted::Unshifted, "{".to_string())),
            ((Shifted::Unshifted, 0x30), (Shifted::Unshifted, "]".to_string())),
            ((Shifted::Shifted, 0x30), (Shifted::Unshifted, "}".to_string())),
            ((Shifted::Unshifted, 0x31), (Shifted::Unshifted, "\\".to_string())),
            ((Shifted::Shifted, 0x31), (Shifted::Unshifted, "|".to_string())),
            ((Shifted::Unshifted, 0x33), (Shifted::Unshifted, ";".to_string())),
            ((Shifted::Shifted, 0x33), (Shifted::Unshifted, ":".to_string())),
            ((Shifted::Unshifted, 0x34), (Shifted::Unshifted, "'".to_string())),
            ((Shifted::Shifted, 0x34), (Shifted::Unshifted, "\"".to_string())),
            ((Shifted::Unshifted, 0x35), (Shifted::Unshifted, "`".to_string())),
            ((Shifted::Shifted, 0x35), (Shifted::Unshifted, "~".to_string())),
            ((Shifted::Unshifted, 0x36), (Shifted::Unshifted, ",".to_string())),
            ((Shifted::Shifted, 0x36), (Shifted::Unshifted, "<".to_string())),
            ((Shifted::Unshifted, 0x37), (Shifted::Unshifted, ".".to_string())),
            ((Shifted::Shifted, 0x37), (Shifted::Unshifted, ">".to_string())),
            ((Shifted::Unshifted, 0x38), (Shifted::Unshifted, "/".to_string())),
            ((Shifted::Shifted, 0x38), (Shifted::Unshifted, "?".to_string())),
            ((Shifted::ShiftAgnostic, 0x39), (Shifted::ShiftAgnostic, "<capslock>".to_string())),
            ((Shifted::ShiftAgnostic, 0x46), (Shifted::ShiftAgnostic, "<printscreen>".to_string())),
            ((Shifted::ShiftAgnostic, 0x47), (Shifted::ShiftAgnostic, "<scrolllock>".to_string())),
            ((Shifted::ShiftAgnostic, 0x48), (Shifted::ShiftAgnostic, "<pause>".to_string())),
            ((Shifted::ShiftAgnostic, 0x49), (Shifted::ShiftAgnostic, "<insert>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4a), (Shifted::ShiftAgnostic, "<home>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4b), (Shifted::ShiftAgnostic, "<pageup>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4c), (Shifted::ShiftAgnostic, "<delete>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4d), (Shifted::ShiftAgnostic, "<end>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4e), (Shifted::ShiftAgnostic, "<pagedown>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4f), (Shifted::ShiftAgnostic, "<right>".to_string())),
            ((Shifted::ShiftAgnostic, 0x50), (Shifted::ShiftAgnostic, "<left>".to_string())),
            ((Shifted::ShiftAgnostic, 0x51), (Shifted::ShiftAgnostic, "<down>".to_string())),
            ((Shifted::ShiftAgnostic, 0x52), (Shifted::ShiftAgnostic, "<up>".to_string())),
            ((Shifted::ShiftAgnostic, 0x53), (Shifted::ShiftAgnostic, "<numlock>".to_string())),
        ]);

        table
    };

    pub static ref USB_HID_MAP: HashMap<UsbHidKey, UsbHidValue> = 
        USB_HID_TABLE.iter().cloned().collect();

    pub static ref USB_HID_UNMAP: HashMap<String, (Shifted, Shifted, u8)> = {
        USB_HID_TABLE.iter().map(|((s, k), (s2, v))| {
            (v.clone(), (*s, *s2, *k))
        }).collect()
    };
}

#[derive(PartialEq, Clone, Copy, Debug)]
#[derive(VariantArray)]
pub enum FlagField {
    Version,
    KeyRepeat,
    DirectKey,
    JoystickLeftClick,
    DisableBluetooth,
    StickyNum,
    StickyShift,
    HapticFeedback,
    SleepTimeout,
    MouseLeftClickAction,
    MouseMiddleClickAction,
    MouseRightClickAction,
    MouseAccelFactor,
    KeyRepeatDelay,
}

#[derive(Debug)]
enum ReadTypeError {
    InvalidBoolean(String),
}

#[derive(Debug)]
enum TwiddlerConfigError {
    NestedMultipleChord,
    ReadType(ReadTypeError),
    UnknownChordModifier(char),
    UnknownLetter(char),
    EmptyChord,
    StringNotInStringContents(String),
    InvalidUnicode,
    TextConfigInvalidFormat,
    UsingTextConfigAsBinary,
    InvalidKey(String),
}

impl std::fmt::Display for ReadTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            ReadTypeError::InvalidBoolean(s) => write!(f, "InvalidBoolean: '{}'", s),
        }
    }
}
impl Error for ReadTypeError {}



impl std::fmt::Display for TwiddlerConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            TwiddlerConfigError::NestedMultipleChord => write!(f, "NestedMultipleChord"),
            TwiddlerConfigError::ReadType(e) => write!(f, "ReadTypeError: {}", e),
            TwiddlerConfigError::UnknownChordModifier(s) => write!(f, "UnknownChordModifier: '{}'", s),
            TwiddlerConfigError::UnknownLetter(s) => write!(f, "UnknownLetter: '{}'", s),
            TwiddlerConfigError::EmptyChord => write!(f, "EmptyChord"),
            TwiddlerConfigError::StringNotInStringContents(s) => write!(f, "StringNotInStringContents: '{}'", s),
            TwiddlerConfigError::InvalidUnicode => write!(f, "InvalidUnicode"),
            TwiddlerConfigError::TextConfigInvalidFormat => write!(f, "TextConfigInvalidFormat"),
            TwiddlerConfigError::UsingTextConfigAsBinary => write!(f, "UsingTextConfigAsBinary"),
            TwiddlerConfigError::InvalidKey(s) => write!(f, "InvalidKey: '{}'", s),
        }
    }
}
impl Error for TwiddlerConfigError {}



macro_rules! generate_matches {
    (match_maker ($ft:ident, $ftm:ident) {$($tname:ident($tactual:ty)),*$(,)?}$(,)? ($string_to_enum:ident, $enum_to_string:ident, $enum_to_immutable:ident, $enum_to_mutable:ident) = [$(($variant:ident, $name_internal:ident, $name_external:literal, $t:ident)),*$(,)?]) => {
        enum $ft<'a> {
            $($tname(&'a $tactual)),*
        }
        enum $ftm<'a> {
            $($tname(&'a mut $tactual)),*
        }
        fn $string_to_enum(st_in: &str) -> Option<FlagField> {
            match st_in {
                $(
                    $name_external => Some(FlagField::$variant),
                )*
                _ => None,
            }
        }
        fn $enum_to_string(field: FlagField) -> &'static str {
            match field {
                $(
                    FlagField::$variant => $name_external,
                )*
            }
        }
        fn $enum_to_immutable<'a>(field: FlagField, config: &'a TwiddlerConfig) -> FieldType<'a> {
            match field {
                $(
                    FlagField::$variant => FieldType::$t(&config.$name_internal),
                )*
            }
        }
        fn $enum_to_mutable<'a>(field: FlagField, config: &'a mut TwiddlerConfig) -> FieldTypeMut<'a> {
            match field {
                $(
                    FlagField::$variant => FieldTypeMut::$t(&mut config.$name_internal),
                )*
            }
        }
    }
}

generate_matches! {
    match_maker (FieldType, FieldTypeMut) {
        Unit(()),
        Bool(bool),
        U8(u8),
        U16(u16),
    }
    (string_to_field_, field_to_string_, get_field_ptr_immut_, get_field_ptr_mut_) = [
        (Version,                version,                   "version",                Unit),
        (KeyRepeat,              key_repeat,                "keyRepeat",              Bool),
        (DirectKey,              direct_key,                "directKey",              Bool),
        (JoystickLeftClick,      joystick_left_click,       "joystickLeftClick",      Bool),
        (DisableBluetooth,       disable_bluetooth,         "disableBluetooth",       Bool),
        (StickyNum,              sticky_num,                "stickyNum",              Bool),
        (StickyShift,            sticky_shift,              "stickyShift",            Bool),
        (HapticFeedback,         haptic_feedback,           "hapticFeedback",         Bool),
        (SleepTimeout,           sleep_timeout,             "sleepTimeout",           U16),
        (MouseLeftClickAction,   mouse_left_click_action,   "mouseLeftClickAction",   U16),
        (MouseMiddleClickAction, mouse_middle_click_action, "mouseMiddleClickAction", U16),
        (MouseRightClickAction,  mouse_right_click_action,  "mouseRightClickAction",  U16),
        (MouseAccelFactor,       mouse_accel_factor,        "mouseAccelFactor",       U8),
        (KeyRepeatDelay,         key_repeat_delay,          "keyRepeatDelay",         U8),
    ]
}



impl FlagField {
    fn string_to_field(key: &str) -> Option<FlagField> {
        string_to_field_(key)
    }

    fn field_to_string(&self) -> &'static str {
        field_to_string_(*self)
    }

    fn get_field_ptr_immut<'a>(&self, config: &'a TwiddlerConfig) -> FieldType<'a> {
        get_field_ptr_immut_(*self, config)
    }

    fn get_field_ptr_mut<'a>(&self, config: &'a mut TwiddlerConfig) -> FieldTypeMut<'a> {
        get_field_ptr_mut_(*self, config)
    }

    fn read_into_config(config: &mut TwiddlerConfig, key: String, value: String) -> Result<Option<(String, String)>, Box<dyn Error>> {
        let field = match FlagField::string_to_field(&key) {
            None => {
                return Ok(Some((key, value)));
            },
            Some(v) => v
        };
        let mut field_ptr = field.get_field_ptr_mut(config);
        
        fn set_field(field_ptr: &mut FieldTypeMut, value: String) -> Result<(), Box<dyn Error>> {
            match field_ptr {
                FieldTypeMut::Unit(()) => (),
                FieldTypeMut::Bool(v) => **v = read_bool(value)?,
                FieldTypeMut::U8(v) => **v = value.parse()?,
                FieldTypeMut::U16(v) => **v = value.parse()?,
            };
            Ok(())
        }

        match set_field(&mut field_ptr, value) {
            Ok(()) => Ok(None),
            Err(_) => Err(Box::new(TwiddlerConfigError::InvalidKey(key))),
        }
    }
}

// === Reading ===

fn read_chord_mapping<R: Read>(reader: &mut R) -> std::io::Result<ChordOutput> {
    let mapping_l = reader.read_u8()?;
    let mapping_h = reader.read_u8()?;

    Ok(match mapping_l {
        0xFF => ChordOutput::MultipleChordIndex { string_index: mapping_h },
        _ => ChordOutput::SingleChord { modifier: mapping_l, key_code: mapping_h },
    })
}

fn read_chord<R: Read>(reader: &mut R) -> std::io::Result<RawChord> {
    let raw_keys = reader.read_u16::<LittleEndian>()?;
    let keys: Vec<u16> = (0..16)
        .filter(|&i| raw_keys & (1 << i) != 0)
        .collect();

    let chord = read_chord_mapping(reader)?;

    Ok(RawChord { keys, output: chord })
}

fn read_location<R: Read>(reader: &mut R) -> std::io::Result<u32> {
    Ok(reader.read_u32::<LittleEndian>()?)
}

fn read_string_contents(contents: &[u8], offset: usize) -> std::io::Result<Vec<ChordOutput>> {
    let mut cursor = Cursor::new(&contents[offset..]);
    let len = cursor.read_u16::<LittleEndian>()?;
    (0..(len / 2 - 1))
        .map(|_| read_chord_mapping(&mut cursor))
        .collect()
}

pub fn read_config(contents: &[u8]) -> std::io::Result<TwiddlerConfig> {
    let mut cursor = Cursor::new(contents);
    
    let version = cursor.read_u8()?;
    if version != 5 {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Only works on version 5"));
    }

    // sequentially read in the config information from the binary
    let flags_a = cursor.read_u8()?;
    let nchords = cursor.read_u16::<LittleEndian>()? as usize;
    let sleep_timeout = cursor.read_u16::<LittleEndian>()?;
    let mouse_left_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_middle_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_right_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_accel_factor = cursor.read_u8()?;
    let key_repeat_delay = cursor.read_u8()?;
    let _ = cursor.read_u8()?;  // flags_b (unused)
    let flags_c = cursor.read_u8()?;


    let config = TwiddlerConfig {
        version: (),
        key_repeat: flags_a & 0x01 != 0,
        direct_key: flags_a & 0x02 != 0,
        joystick_left_click: flags_a & 0x04 != 0,
        disable_bluetooth: flags_a & 0x08 != 0,
        sticky_num: flags_a & 0x10 != 0,
        sticky_shift: flags_a & 0x80 != 0,
        haptic_feedback: flags_c & 0x01 != 0,

        sleep_timeout,
        mouse_left_click_action,
        mouse_middle_click_action,
        mouse_right_click_action,
        mouse_accel_factor,
        key_repeat_delay,

        chords: Vec::new(), // We'll fill this later
    };

    let mut chords = Vec::with_capacity(nchords);
    for _ in 0..nchords {
        chords.push(read_chord(&mut cursor)?);
    }

    let max_string_location = chords.iter()
        .filter_map(|c| match c.output {
            ChordOutput::MultipleChordIndex { string_index } => Some(string_index as usize),
            _ => None,
        })
        .max()
        .unwrap_or(0);

    let mut string_locations = Vec::with_capacity(max_string_location + 1);
    for _ in 0..=max_string_location {
        string_locations.push(read_location(&mut cursor)?);
    }

    let chords: std::io::Result<Vec<RawChord>> = chords.into_iter()
        .map(|chord| {
            match chord.output {
                ChordOutput::MultipleChordIndex { string_index } => {
                    let multiple_chord = read_string_contents(contents, string_locations[string_index as usize] as usize)?;
                    Ok(RawChord { keys: chord.keys, output: ChordOutput::MultipleChord(multiple_chord) })
                },
                _ => Ok(chord),
            }
        })
        .collect();

    Ok(TwiddlerConfig { chords: chords?, ..config })
}

pub fn read_text_config(contents: String) -> Result<TwiddlerConfig, Box<dyn Error>> {
    let mut config = TwiddlerConfig::default();
    
    for line in contents.lines() {
        let (key, value) = split_key_value(line);
        match FlagField::read_into_config(&mut config, key, value) {
            Ok(None) => {},
            Ok(Some((key, value))) => {
                let chord = parse_chord(key, value)?;
                config.chords.push(chord);
            }
            Err(e) => return Err(e),
        }
    }

    // sort chords by key_list_to_int--this is important! the config file won't be accepted otherwise.
    sort_chords(&mut config.chords);
    
    Ok(config)
}

fn split_key_value(s: &str) -> (String, String) {
    let mut parts = s.trim().splitn(2, ' ');
    let key = parts.next().unwrap_or("").trim().to_string();
    // TODO: this used to use map_or. is this ok?
    let value = parts.next().unwrap_or("").trim().to_string();
    (key, value)
}

fn read_bool(s: String) -> Result<bool, Box<dyn Error>> {
    match s.as_str() {
        "0" => Ok(false),
        "1" => Ok(true),
        _ => Err(Box::new(TwiddlerConfigError::ReadType(ReadTypeError::InvalidBoolean(s)))),
    }
}

fn parse_chord(key: String, value: String) -> Result<RawChord, Box<dyn Error>> {
    Ok(RawChord {
        keys: parse_chord_keys(key)?,
        output: text_to_usb(value)?,
    })
}

fn parse_chord_modifiers(s: String) -> Result<Vec<u16>, Box<dyn Error>> {
    let mut chord_modifiers = Vec::new();
    let mut chars = s.chars();
    while let Some(c) = chars.next() {
        match c {
            'N' => chord_modifiers.push(0),
            'A' => chord_modifiers.push(4),
            'C' => chord_modifiers.push(8),
            'S' => chord_modifiers.push(12),
             _  => return Err(Box::new(TwiddlerConfigError::UnknownChordModifier(c))),
        }
    }
    Ok(chord_modifiers)
}

fn parse_letter(c: char) -> Result<Option<u16>, Box<dyn Error>> {
    Ok(match c {
        'O' => None,
        'L' => Some(1),
        'M' => Some(2),
        'R' => Some(3),
        _ => return Err(Box::new(TwiddlerConfigError::UnknownLetter(c))),
    })
}

fn parse_main_chord(s: String) -> Result<Vec<u16>, Box<dyn Error>> {
    let mut chord: Vec<u16> = Vec::new();
    let mut chars = s.chars();
    let mut col_idx = 0;
    while let Some(c) = chars.next() {
        if c == '(' {
            while let Some(c) = chars.next() {
                if c == ')' {
                    break;
                }
                if let Some(lc) = parse_letter(c)? {
                    chord.push(4*col_idx + lc);
                }
            }
            col_idx += 1;
        } else {
            if let Some(lc) = parse_letter(c)? {
                chord.push(4*col_idx + lc);
            }
            col_idx += 1;
        }
    }
    Ok(chord)
}

fn parse_chord_keys(mut s: String) -> Result<Vec<u16>, Box<dyn Error>> {
    match s.find('+') {
        Some(i) => {
            let main_chord = s.split_off(i+1);  // s is now left with only the modifiers and "+"
            s.pop();  // get rid of the "+"
            let mut p = parse_chord_modifiers(s)?;
            p.extend(parse_main_chord(main_chord)?);
            Ok(p)
        }
        None => parse_main_chord(s),
    }
}

// === Writing ===

fn generate_text_for_keys(keys: &[u16]) -> String {
    let mut result = String::new();
    
    // Generate modifiers
    if keys.contains(&0) { result.push('N'); }
    if keys.contains(&4) { result.push('A'); }
    if keys.contains(&8) { result.push('C'); }
    if keys.contains(&12) { result.push('S'); }
    
    if !result.is_empty() {
        result.push('+');
    }
    
    while result.len() < 5 {
        result.insert(0, ' ');
    }
    
    // Generate main chord
    for row in 0..4 {
        let row_keys: Vec<_> = keys.iter()
            .filter(|&&k| k > 4 * row && k < 4 * (row + 1))
            .map(|&k| k - 4 * row)
            .collect();
        
        if row_keys.is_empty() {
            result.push('O');
        } else if row_keys.len() == 1 {
            result.push(match row_keys[0] {
                1 => 'L',
                2 => 'M',
                3 => 'R',
                _ => unreachable!(),
            });
        } else {
            result.push('(');
            for &k in &row_keys {
                result.push(match k {
                    1 => 'L',
                    2 => 'M',
                    3 => 'R',
                    _ => unreachable!(),
                });
            }
            result.push(')');
        }
    }
    
    result
}

pub fn text_to_usb(s: String) -> Result<ChordOutput, Box<dyn Error>> {
    let outputs = text_to_usb_internal(s)?;
    match outputs.len() {
        0 => Err(Box::new(TwiddlerConfigError::EmptyChord)),
        1 => Ok(outputs[0].clone()),
        _ => Ok(ChordOutput::MultipleChord(outputs)),
    }
}

fn text_to_usb_internal(s: String) -> Result<Vec<ChordOutput>, Box<dyn Error>> {
    let mut result = Vec::new();
    let mut chars = s.chars().peekable();

    fn shifted_with_default_to_mods(shifted: Option<bool>, default: bool) -> u8 {
        let actually_shifted = match shifted {
            Some(v) => v,
            None => default,
        };
        if actually_shifted { 0x20 } else { 0x00 }
    }

    while let Some(c1) = chars.next() {
        let c2_opt = chars.peek();
        match (c1, c2_opt) {
            ('\\', Some(_)) => {
                // the unwrap here is safe because c2 is Some.
                // since c2 was only peeked before, it's necessary to call next() to actually consume it.
                let (shifted, key_code) = unmap_char(&chars.next().unwrap().to_string())?;
                let modifier = shifted_with_default_to_mods(shifted, false);
                result.push(ChordOutput::SingleChord { modifier, key_code });
            }
            ('<', Some(_)) => {
                let mut content = String::new();
                while let Some(next_char) = chars.next() {
                    if next_char == '>' {
                        break;
                    }
                    content.push(next_char);
                }
                let (mods, char_content) = parse_value_modifiers(&content);
                let shift = mods & 0x22 != 0;
                let (parsed_shift, key_code) = unmap_char(char_content)?;
                let modifier = mods | shifted_with_default_to_mods(parsed_shift, shift);
                result.push(ChordOutput::SingleChord { modifier, key_code });
            }
            _ => {
                let (parsed_shift, key_code) = unmap_char(&c1.to_string())?;
                let modifier = shifted_with_default_to_mods(parsed_shift, false);
                result.push(ChordOutput::SingleChord { modifier, key_code });
            }
        }
    }
    Ok(result)
}

fn parse_value_modifiers(s: &str) -> (u8, &str) {
    let mut mods = 0u8;
    let mut chars = s.chars();
    
    while let Some(c) = chars.next() {
        match c {
            'C' => mods |= 0x01,
            'S' => mods |= 0x02,
            'A' => mods |= 0x04,
            '4' => mods |= 0x08,
            'R' => {
                match chars.next() {
                    Some('C') => mods |= 0x10,
                    Some('S') => mods |= 0x20,
                    Some('A') => mods |= 0x40,
                    Some('4') => mods |= 0x80,
                    _ => break,
                }
            }
            '-' => {
                return (mods, chars.as_str());
            }
            _ => {
                return (mods, s);
            }
        }
    }
    (mods, "")
}


pub fn unmap_char(s_raw: &str) -> Result<(Option<bool>, u8), Box<dyn Error>> {
    let s = if s_raw.len() == 1 { s_raw } else { &("<".to_string() + s_raw + ">") };
    let (shifted, key_code) = match {
        let v = USB_HID_UNMAP.get(s);
        v
        }
        .map(|&(shift1, _shift2, code)| {
            match shift1 {
                Shifted::Shifted => (Some(true), code),
                Shifted::Unshifted => (Some(false), code),
                Shifted::ShiftAgnostic => (None, code),
            }
        }) {
            Some(v) => v,
            None => return Err(Box::new(TwiddlerConfigError::StringNotInStringContents(s.to_string()))),
        };
    Ok((shifted, key_code))
}



pub fn usb_hid_to_text(shift: bool, n: u8) -> (bool, String) {
    let shift_state = if shift { Shifted::Shifted } else { Shifted::Unshifted };
    
    if let Some((shift_agnostic, value)) = USB_HID_MAP.get(&(shift_state, n)) {
        let output_shift = match shift_agnostic {
            Shifted::ShiftAgnostic => shift,
            Shifted::Shifted => true,
            Shifted::Unshifted => false,
        };
        (output_shift, value.clone())
    } else if let Some((shift_agnostic, value)) = USB_HID_MAP.get(&(Shifted::ShiftAgnostic, n)) {
        let output_shift = match shift_agnostic {
            Shifted::ShiftAgnostic => shift,
            Shifted::Shifted => true,
            Shifted::Unshifted => false,
        };
        (output_shift, value.clone())
    } else {
        (shift, format!("<0x{:02X}>", n))
    }
}

pub fn generate_text_config(config: &TwiddlerConfig) -> Result<String, Box<dyn Error>> {
    let mut result = Vec::new();

    for flag_field in FlagField::VARIANTS.iter() {
        result.push(format!("{} {}", flag_field.field_to_string(), match flag_field.get_field_ptr_immut(config) {
            FieldType::Unit(()) => "0".to_string(),
            FieldType::Bool(&b) => bool_to_int(b).to_string(),
            FieldType::U8(&v) => v.to_string(),
            FieldType::U16(&v) => v.to_string(),
        }));
    }

    for chord in &config.chords {
        // !!!! DIFFERS FROM ORIGINAL !!!!
        // a chord with no output caused a panic in the original (OOOO <0x0> was written but could not be read)
        // so, we filter those out
        if let ChordOutput::SingleChord { key_code, .. } = chord.output {
            if key_code == 0 {
                continue;
            }
        }

        result.push(format!("{} {}", 
            generate_text_for_keys(&chord.keys), 
            render_chord_output(&chord.output)?
        ));
    }
    Ok(result.join("\n") + "\n")
}

fn bool_to_int(b: bool) -> i32 {
    if b { 1 } else { 0 }
}

fn render_chord_output(output: &ChordOutput) -> Result<String, Box<dyn Error>> {
    Ok(match output {
        ChordOutput::SingleChord { modifier, key_code } => {
            render_single_chord(*modifier, *key_code)?
        },
        ChordOutput::MultipleChordIndex { string_index } => {
            format!("MultipleChordIndex {}", string_index)
        },
        ChordOutput::MultipleChord(chords) => {
            chords.iter()
                .map(|c| match c {
                    ChordOutput::SingleChord { modifier, key_code } => 
                        render_single_chord(*modifier, *key_code),
                    _ => Err(Box::new(TwiddlerConfigError::NestedMultipleChord))?,
                })
                .collect::<Result<Vec<_>, Box<dyn Error>>>()?
                .join("")
        },
    })
}

fn render_single_chord(m: u8, c: u8) -> Result<String, Box<dyn Error>> {
    let mut result = String::new();
    let (shift, c) = usb_hid_to_text(m & 0x22 != 0, c);
    let mods = render_modifiers(m & (if shift { 0xFF } else { 0xDD }));
    let escape = if c == "<" && mods.is_empty() { "\\" } else { "" };
    
    if !mods.is_empty() {
        write!(result, "<{}-", mods)?;
    }
    
    result.push_str(escape);
    
    if !mods.is_empty() && c.starts_with('<') && c.ends_with('>') {
        result.push_str(&c[1..c.len()-1]);
    } else {
        result.push_str(&c);
    }
    if !mods.is_empty() {
        result.push('>');
    }
    Ok(result)
}

fn render_modifiers(m: u8) -> String {
    let mut result = String::new();
    if m & 0x01 != 0 { result.push('C'); }
    if m & 0x02 != 0 { result.push('S'); }
    if m & 0x04 != 0 { result.push('A'); }
    if m & 0x08 != 0 { result.push('4'); }
    if m & 0x10 != 0 { result.push_str("RC"); }
    if m & 0x20 != 0 { result.push_str("RS"); }
    if m & 0x40 != 0 { result.push_str("RA"); }
    if m & 0x80 != 0 { result.push_str("R4"); }
    result
}

pub fn generate_bin_config(config: &TwiddlerConfig) -> Result<Vec<u8>, Box<dyn Error>> {
    let mut writer = Cursor::new(Vec::new());

    // Write version (only compatible with v5)
    writer.write_u8(5)?;

    // Write flags
    let flags = (if config.key_repeat { 0x01 } else { 0 }) |
                (if config.direct_key { 0x02 } else { 0 }) |
                (if config.joystick_left_click { 0x04 } else { 0 }) |
                (if config.disable_bluetooth { 0x08 } else { 0 }) |
                (if config.sticky_num { 0x10 } else { 0 }) |
                (if config.sticky_shift { 0x80 } else { 0 });
    writer.write_u8(flags)?;
    
    // Write number of chords
    writer.write_u16::<LittleEndian>(config.chords.len() as u16)?;
    
    // Write config values
    writer.write_u16::<LittleEndian>(config.sleep_timeout)?;
    writer.write_u16::<LittleEndian>(config.mouse_left_click_action)?;
    writer.write_u16::<LittleEndian>(config.mouse_middle_click_action)?;
    writer.write_u16::<LittleEndian>(config.mouse_right_click_action)?;
    writer.write_u8(config.mouse_accel_factor)?;
    writer.write_u8(config.key_repeat_delay)?;

    // Write additional flags
    writer.write_u8(0)?;  // flagsB
    writer.write_u8(if config.haptic_feedback { 0x01 } else { 0 })?;  // flagsC

    // whether to use the same reference index to the multiple key output table for chords with the same output
    const USE_DEDUPE: bool = true;
    let mut string_contents = Vec::new();
    if !USE_DEDUPE {
        // Write chords
        let mut multiple_chord_count = 0;
        for chord in &config.chords {
            write_chord(&mut writer, chord)?;
            if let ChordOutput::MultipleChord(outputs) = &chord.output {
                string_contents.push(outputs.clone());
                writer.write_u8(multiple_chord_count)?;
                multiple_chord_count += 1;
            }
        }
    } else {
        // Collect and deduplicate string contents
        let mut string_indices = Vec::new();
        for chord in &config.chords {
            write_chord(&mut writer, chord)?;
            if let ChordOutput::MultipleChord(outputs) = &chord.output {
                let index = match string_contents.iter().position(|sc| sc == outputs) {
                    Some(index) => {
                        index
                    }
                    None => {
                        string_contents.len()
                    }
                };
                string_indices.push(index);
                string_contents.push(outputs.clone());
                writer.write_u8(index as u8)?;
            }
        }
    }

    // Write string locations
    let base_string_content_location = 16 + 4 * (config.chords.len() as u32) + 4 * (string_contents.len() as u32);
    let mut current_location = base_string_content_location;
    for content in &string_contents {
        writer.write_u32::<LittleEndian>(current_location)?;
        current_location += 2 + 2 * (content.len() as u32);
    }

    // Write string contents
    for content in &string_contents {
        writer.write_u16::<LittleEndian>((2 + 2 * content.len()) as u16)?;
        for output in content {
            write_chord_output(&mut writer, output)?;
        }
    }

    Ok(writer.into_inner())
}

fn key_list_to_int(keys: &[u16]) -> u16 {
    keys.iter().fold(0, |acc, &key| acc | (1 << key))
}

pub fn sort_chords(chords: &mut Vec<RawChord>) {
    // sort chords by key_list_to_int--this is important! the config file won't be accepted otherwise.
    chords.sort_by_key(|c| key_list_to_int(&c.keys));
}

fn write_chord<W: WriteBytesExt>(writer: &mut W, chord: &RawChord) -> std::io::Result<()> {
    writer.write_u16::<LittleEndian>(key_list_to_int(&chord.keys))?;
    write_chord_output(writer, &chord.output)
}

fn write_chord_output<W: WriteBytesExt>(writer: &mut W, output: &ChordOutput) -> std::io::Result<()> {
    match output {
        ChordOutput::SingleChord { modifier, key_code } => {
            writer.write_u8(*modifier)?;
            writer.write_u8(*key_code)?;
        },
        ChordOutput::MultipleChordIndex { string_index } => {
            writer.write_u8(0xFF)?;
            writer.write_u8(*string_index)?;
        },
        ChordOutput::MultipleChord(_) => {
            writer.write_u8(0xFF)?;
            // the index of the string in the string contents is written outside of this function
        },
    }
    Ok(())
}

fn check_overwrite(old_filename: &str, new_filename: &str) -> std::io::Result<()> {
    let new_path = Path::new(new_filename);
    if new_path.exists() {
        let source_modification_time = fs::metadata(&old_filename)?.modified()?;
        let target_modification_time = fs::metadata(&new_filename)?.modified()?;

        if source_modification_time <= target_modification_time {
            return Err(std::io::Error::new(
                std::io::ErrorKind::AlreadyExists,
                format!("Refusing to overwrite more-recently modified file {:?}", new_filename)
            ));
        }
    }
    Ok(())
}

fn create_filename(filename: &str, extension: &str) -> Result<String, Box<dyn Error>> {
    let new_filename = match Path::new(filename).with_extension(extension).to_str() {
        Some(p) => p,
        None => return Err(Box::new(TwiddlerConfigError::InvalidUnicode)),
    }.to_string();
    Ok(new_filename.to_string())
}

pub fn txt_to_cfg(filename: &str) -> Result<String, Box<dyn Error>> {
    let contents = fs::read(filename)?;
    // if the file doesn't start with 'version 0\n', error
    if !contents.starts_with(b"version 0\n") {
        return Err(Box::new(TwiddlerConfigError::TextConfigInvalidFormat));
    }

    let new_filename = create_filename(filename, "cfg")?;
    check_overwrite(filename, &new_filename)?;
    let config = read_text_config(String::from_utf8(contents)?)?;
    fs::write(&new_filename, generate_bin_config(&config)?)?;
    Ok(new_filename)
}

pub fn cfg_to_txt(filename: &str) -> Result<String, Box<dyn Error>> {
    let contents = fs::read(filename)?;
    // if the file starts with 'version 0\n', error
    if contents.starts_with(b"version 0\n") {
        return Err(Box::new(TwiddlerConfigError::UsingTextConfigAsBinary));
    }

    let new_filename = create_filename(filename, "txt")?;
    check_overwrite(filename, &new_filename)?;
    let config = read_config(&contents)?;
    fs::write(&new_filename, generate_text_config(&config)?)?;
    Ok(new_filename)
}
