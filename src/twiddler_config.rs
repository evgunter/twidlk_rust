// this is a port of
// https://github.com/edanaher/twidlk/blob/master/src/Main.hs
// mostly generated by Claude 3.5 Sonnet (but bugs fixed by me)

// licensed under GPLv3

// === Data ===

use lazy_static::lazy_static;

use std::collections::HashMap;
use std::fs;
use std::path::Path;
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use std::io::{Read, Cursor};
use std::fmt::Write;

#[derive(Debug)]
pub struct TwiddlerConfig {
    pub key_repeat: bool,
    pub direct_key: bool,
    pub joystick_left_click: bool,
    pub disable_bluetooth: bool,
    pub sticky_num: bool,
    pub sticky_shift: bool,
    pub haptic_feedback: bool,

    pub sleep_timeout: u16,
    pub mouse_left_click_action: u16,
    pub mouse_middle_click_action: u16,
    pub mouse_right_click_action: u16,
    pub mouse_accel_factor: u8,
    pub key_repeat_delay: u8,

    pub chords: Vec<RawChord>,
}

impl TwiddlerConfig {
    fn default() -> Self {
        TwiddlerConfig {
            key_repeat: false,
            direct_key: false,
            joystick_left_click: true,
            disable_bluetooth: false,
            sticky_num: false,
            sticky_shift: false,
            haptic_feedback: false,

            sleep_timeout: 1500,
            mouse_left_click_action: 0,
            mouse_middle_click_action: 0,
            mouse_right_click_action: 0,
            mouse_accel_factor: 10,
            key_repeat_delay: 100,

            chords: Vec::new(),
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ChordOutput {
    SingleChord { modifier: u8, key_code: u8 },
    MultipleChordIndex { string_index: u8 },
    MultipleChord(Vec<ChordOutput>),
}

#[derive(Debug)]
pub struct RawChord {
    pub keys: Vec<u16>,
    pub output: ChordOutput,
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum Shifted {
    Shifted,
    Unshifted,
    ShiftAgnostic,
}

pub type UsbHidKey = (Shifted, u8);
pub type UsbHidValue = (Shifted, String);

lazy_static! {
    pub static ref USB_HID_TABLE: Vec<(UsbHidKey, UsbHidValue)> = {
        let mut table = Vec::new();

        // Lowercase letters
        table.extend((0x04..=0x1d).map(|n| {
            ((Shifted::Unshifted, n), (Shifted::Unshifted, String::from((n - 0x04 + b'a') as char)))
        }));

        // Uppercase letters
        table.extend((0x04..=0x1d).map(|n| {
            ((Shifted::Shifted, n), (Shifted::Unshifted, String::from((n - 0x04 + b'A') as char)))
        }));

        // Numbers
        table.extend((0x1e..=0x26).map(|n| {
            ((Shifted::Unshifted, n), (Shifted::Unshifted, String::from((n - 0x1e + b'1') as char)))
        }));

        // Zero
        table.push(((Shifted::Unshifted, 0x27), (Shifted::Unshifted, "0".to_string())));

        // Function keys
        table.extend((0x3a..=0x45).map(|n| {
            ((Shifted::ShiftAgnostic, n), (Shifted::ShiftAgnostic, format!("<F{}>", n - 0x39)))
        }));

        // Special characters
        table.extend(vec![
            ((Shifted::Shifted, 0x1e), (Shifted::Unshifted, "!".to_string())),
            ((Shifted::Shifted, 0x1f), (Shifted::Unshifted, "@".to_string())),
            ((Shifted::Shifted, 0x20), (Shifted::Unshifted, "#".to_string())),
            ((Shifted::Shifted, 0x21), (Shifted::Unshifted, "$".to_string())),
            ((Shifted::Shifted, 0x22), (Shifted::Unshifted, "%".to_string())),
            ((Shifted::Shifted, 0x23), (Shifted::Unshifted, "^".to_string())),
            ((Shifted::Shifted, 0x24), (Shifted::Unshifted, "&".to_string())),
            ((Shifted::Shifted, 0x25), (Shifted::Unshifted, "*".to_string())),
            ((Shifted::Shifted, 0x26), (Shifted::Unshifted, "(".to_string())),
            ((Shifted::Shifted, 0x27), (Shifted::Unshifted, ")".to_string())),
            ((Shifted::ShiftAgnostic, 0x28), (Shifted::ShiftAgnostic, "<return>".to_string())),
            ((Shifted::ShiftAgnostic, 0x29), (Shifted::ShiftAgnostic, "<escape>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2a), (Shifted::ShiftAgnostic, "<backspace>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2b), (Shifted::ShiftAgnostic, "<tab>".to_string())),
            ((Shifted::ShiftAgnostic, 0x2c), (Shifted::ShiftAgnostic, "<space>".to_string())),
            ((Shifted::Unshifted, 0x2d), (Shifted::Unshifted, "-".to_string())),
            ((Shifted::Shifted, 0x2d), (Shifted::Unshifted, "_".to_string())),
            ((Shifted::Unshifted, 0x2e), (Shifted::Unshifted, "=".to_string())),
            ((Shifted::Shifted, 0x2e), (Shifted::Unshifted, "+".to_string())),
            ((Shifted::Unshifted, 0x2f), (Shifted::Unshifted, "[".to_string())),
            ((Shifted::Shifted, 0x2f), (Shifted::Unshifted, "{".to_string())),
            ((Shifted::Unshifted, 0x30), (Shifted::Unshifted, "]".to_string())),
            ((Shifted::Shifted, 0x30), (Shifted::Unshifted, "}".to_string())),
            ((Shifted::Unshifted, 0x31), (Shifted::Unshifted, "\\".to_string())),
            ((Shifted::Shifted, 0x31), (Shifted::Unshifted, "|".to_string())),
            ((Shifted::Unshifted, 0x33), (Shifted::Unshifted, ";".to_string())),
            ((Shifted::Shifted, 0x33), (Shifted::Unshifted, ":".to_string())),
            ((Shifted::Unshifted, 0x34), (Shifted::Unshifted, "'".to_string())),
            ((Shifted::Shifted, 0x34), (Shifted::Unshifted, "\"".to_string())),
            ((Shifted::Unshifted, 0x35), (Shifted::Unshifted, "`".to_string())),
            ((Shifted::Shifted, 0x35), (Shifted::Unshifted, "~".to_string())),
            ((Shifted::Unshifted, 0x36), (Shifted::Unshifted, ",".to_string())),
            ((Shifted::Shifted, 0x36), (Shifted::Unshifted, "<".to_string())),
            ((Shifted::Unshifted, 0x37), (Shifted::Unshifted, ".".to_string())),
            ((Shifted::Shifted, 0x37), (Shifted::Unshifted, ">".to_string())),
            ((Shifted::Unshifted, 0x38), (Shifted::Unshifted, "/".to_string())),
            ((Shifted::Shifted, 0x38), (Shifted::Unshifted, "?".to_string())),
            ((Shifted::ShiftAgnostic, 0x39), (Shifted::ShiftAgnostic, "<capslock>".to_string())),
            ((Shifted::ShiftAgnostic, 0x46), (Shifted::ShiftAgnostic, "<printscreen>".to_string())),
            ((Shifted::ShiftAgnostic, 0x47), (Shifted::ShiftAgnostic, "<scrolllock>".to_string())),
            ((Shifted::ShiftAgnostic, 0x48), (Shifted::ShiftAgnostic, "<pause>".to_string())),
            ((Shifted::ShiftAgnostic, 0x49), (Shifted::ShiftAgnostic, "<insert>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4a), (Shifted::ShiftAgnostic, "<home>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4b), (Shifted::ShiftAgnostic, "<pageup>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4c), (Shifted::ShiftAgnostic, "<delete>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4d), (Shifted::ShiftAgnostic, "<end>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4e), (Shifted::ShiftAgnostic, "<pagedown>".to_string())),
            ((Shifted::ShiftAgnostic, 0x4f), (Shifted::ShiftAgnostic, "<right>".to_string())),
            ((Shifted::ShiftAgnostic, 0x50), (Shifted::ShiftAgnostic, "<left>".to_string())),
            ((Shifted::ShiftAgnostic, 0x51), (Shifted::ShiftAgnostic, "<down>".to_string())),
            ((Shifted::ShiftAgnostic, 0x52), (Shifted::ShiftAgnostic, "<up>".to_string())),
            ((Shifted::ShiftAgnostic, 0x53), (Shifted::ShiftAgnostic, "<numlock>".to_string())),
        ]);

        table
    };

    pub static ref USB_HID_MAP: HashMap<UsbHidKey, UsbHidValue> = 
        USB_HID_TABLE.iter().cloned().collect();

    pub static ref USB_HID_UNMAP: HashMap<String, (Shifted, Shifted, u8)> = {
        USB_HID_TABLE.iter().map(|((s, k), (s2, v))| {
            (v.clone(), (*s, *s2, *k))
        }).collect()
    };
}

pub const FLAG_FIELDS: &[&str] = &[
    "version",
    "keyRepeat",
    "directKey",
    "joystickLeftClick",
    "disableBluetooth",
    "stickyNum",
    "stickyShift",
    "sleepTimeout",
    "mouseLeftClickAction",
    "mouseMiddleClickAction",
    "mouseRightClickAction",
    "mouseAccelFactor",
    "keyRepeatDelay",
    "hapticFeedback"
];


// === Reading ===

fn read_chord_mapping<R: Read>(reader: &mut R) -> std::io::Result<ChordOutput> {
    let mapping_l = reader.read_u8()?;
    let mapping_h = reader.read_u8()?;

    Ok(match mapping_l {
        0xFF => ChordOutput::MultipleChordIndex { string_index: mapping_h },
        _ => ChordOutput::SingleChord { modifier: mapping_l, key_code: mapping_h },
    })
}

fn read_chord<R: Read>(reader: &mut R) -> std::io::Result<RawChord> {
    let raw_keys = reader.read_u16::<LittleEndian>()?;
    let keys: Vec<u16> = (0..16)
        .filter(|&i| raw_keys & (1 << i) != 0)
        .collect();

    let chord = read_chord_mapping(reader)?;

    Ok(RawChord { keys, output: chord })
}

fn read_location<R: Read>(reader: &mut R) -> std::io::Result<u32> {
    Ok(reader.read_u32::<LittleEndian>()?)
}

fn read_string_contents(contents: &[u8], offset: usize) -> std::io::Result<Vec<ChordOutput>> {
    let mut cursor = Cursor::new(&contents[offset..]);
    let len = cursor.read_u16::<LittleEndian>()?;
    (0..(len / 2 - 1))
        .map(|_| read_chord_mapping(&mut cursor))
        .collect()
}

pub fn read_config(contents: &[u8]) -> std::io::Result<TwiddlerConfig> {
    let mut cursor = Cursor::new(contents);
    
    let version = cursor.read_u8()?;
    if version != 5 {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Only works on version 5"));
    }

    // sequentially read in the config information from the binary
    let flags_a = cursor.read_u8()?;
    let nchords = cursor.read_u16::<LittleEndian>()? as usize;
    let sleep_timeout = cursor.read_u16::<LittleEndian>()?;
    let mouse_left_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_middle_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_right_click_action = cursor.read_u16::<LittleEndian>()?;
    let mouse_accel_factor = cursor.read_u8()?;
    let key_repeat_delay = cursor.read_u8()?;
    let _ = cursor.read_u8()?;  // flags_b (unused)
    let flags_c = cursor.read_u8()?;


    let config = TwiddlerConfig {
        key_repeat: flags_a & 0x01 != 0,
        direct_key: flags_a & 0x02 != 0,
        joystick_left_click: flags_a & 0x04 != 0,
        disable_bluetooth: flags_a & 0x08 != 0,
        sticky_num: flags_a & 0x10 != 0,
        sticky_shift: flags_a & 0x80 != 0,

        sleep_timeout,
        mouse_left_click_action,
        mouse_middle_click_action,
        mouse_right_click_action,

        mouse_accel_factor,
        key_repeat_delay,

        haptic_feedback: flags_c & 0x01 != 0,

        chords: Vec::new(), // We'll fill this later
    };

    let mut chords = Vec::with_capacity(nchords);
    for _ in 0..nchords {
        chords.push(read_chord(&mut cursor)?);
    }

    let max_string_location = chords.iter()
        .filter_map(|c| match c.output {
            ChordOutput::MultipleChordIndex { string_index } => Some(string_index as usize),
            _ => None,
        })
        .max()
        .unwrap_or(0);

    let mut string_locations = Vec::with_capacity(max_string_location + 1);
    for _ in 0..=max_string_location {
        string_locations.push(read_location(&mut cursor)?);
    }

    let chords: std::io::Result<Vec<RawChord>> = chords.into_iter()
        .map(|chord| {
            match chord.output {
                ChordOutput::MultipleChordIndex { string_index } => {
                    let multiple_chord = read_string_contents(contents, string_locations[string_index as usize] as usize)?;
                    Ok(RawChord { keys: chord.keys, output: ChordOutput::MultipleChord(multiple_chord) })
                },
                _ => Ok(chord),
            }
        })
        .collect();

    Ok(TwiddlerConfig { chords: chords?, ..config })
}

pub fn read_text_config(contents: &str) -> TwiddlerConfig {
    let mut config = TwiddlerConfig::default();
    
    for line in contents.lines() {
        let (key, value) = split_key_value(line);

        if FLAG_FIELDS.contains(&key) {
            match key {
                "version" => {}, // Ignore version
                "keyRepeat" => config.key_repeat = read_bool(value),
                "directKey" => config.direct_key = read_bool(value),
                "joystickLeftClick" => config.joystick_left_click = read_bool(value),
                "disableBluetooth" => config.disable_bluetooth = read_bool(value),
                "stickyNum" => config.sticky_num = read_bool(value),
                "stickyShift" => config.sticky_shift = read_bool(value),
                "hapticFeedback" => config.haptic_feedback = read_bool(value),
                "sleepTimeout" => config.sleep_timeout = value.parse().unwrap(),
                "mouseLeftClickAction" => config.mouse_left_click_action = value.parse().unwrap(),
                "mouseMiddleClickAction" => config.mouse_middle_click_action = value.parse().unwrap(),
                "mouseRightClickAction" => config.mouse_right_click_action = value.parse().unwrap(),
                "mouseAccelFactor" => config.mouse_accel_factor = value.parse().unwrap(),
                "keyRepeatDelay" => config.key_repeat_delay = value.parse().unwrap(),
                _ => {}
            }
        } else {
            let chord = parse_chord(key, value);
            config.chords.push(chord);
        }
    }
    
    config
}

fn split_key_value(s: &str) -> (&str, &str) {
    let parts: Vec<&str> = s.trim().splitn(2, ' ').collect();
    (parts[0].trim(), parts.get(1).map_or("", |s| s.trim()))
}

fn read_bool(s: &str) -> bool {
    match s {
        "0" => false,
        "1" => true,
        _ => panic!("Invalid boolean: {}", s),
    }
}

fn parse_chord(key: &str, value: &str) -> RawChord {
    RawChord {
        keys: parse_chord_keys(key),
        output: text_to_usb(value),
    }
}

fn parse_chord_modifiers(s: &str) -> Vec<u16> {
    let mut chord_modifiers = Vec::new();
    let mut chars = s.chars();
    while let Some(c) = chars.next() {
        match c {
            'N' => chord_modifiers.push(0),
            'A' => chord_modifiers.push(4),
            'C' => chord_modifiers.push(8),
            'S' => chord_modifiers.push(12),
             _  => panic!("Unknown chord modifier: {}", c),
        }
    }
    chord_modifiers
}

fn parse_letter(c: char) -> Option<u16> {
    match c {
        'O' => None,
        'L' => Some(1),
        'M' => Some(2),
        'R' => Some(3),
        _ => panic!("Unknown letter: {}", c),
    }
}

fn parse_main_chord(s: &str) -> Vec<u16> {
    let mut chord: Vec<u16> = Vec::new();
    let mut chars = s.chars();
    let mut col_idx = 0;
    while let Some(c) = chars.next() {
        if c == '(' {
            while let Some(c) = chars.next() {
                if c == ')' {
                    break;
                }
                if let Some(lc) = parse_letter(c) {
                    chord.push(4*col_idx + lc);
                }
            }
            col_idx += 1;
        } else {
            if let Some(lc) = parse_letter(c) {
                chord.push(4*col_idx + lc);
            }
            col_idx += 1;
        }
    }
    chord
}

fn parse_chord_keys(s: &str) -> Vec<u16> {
    match s.find('+') {
        Some(i) => {
            let mut p = parse_chord_modifiers(&s[..i]);
            p.extend(parse_main_chord(&s[i+1..]));
            p
        }
        None => parse_main_chord(s),
    }
}

// === Writing ===

fn generate_text_for_keys(keys: &[u16]) -> String {
    let mut result = String::new();
    
    // Generate modifiers
    if keys.contains(&0) { result.push('N'); }
    if keys.contains(&4) { result.push('A'); }
    if keys.contains(&8) { result.push('C'); }
    if keys.contains(&12) { result.push('S'); }
    
    if !result.is_empty() {
        result.push('+');
    }
    
    while result.len() < 5 {
        result.insert(0, ' ');
    }
    
    // Generate main chord
    for row in 0..4 {
        let row_keys: Vec<_> = keys.iter()
            .filter(|&&k| k > 4 * row && k < 4 * (row + 1))
            .map(|&k| k - 4 * row)
            .collect();
        
        if row_keys.is_empty() {
            result.push('O');
        } else if row_keys.len() == 1 {
            result.push(match row_keys[0] {
                1 => 'L',
                2 => 'M',
                3 => 'R',
                _ => unreachable!(),
            });
        } else {
            result.push('(');
            for &k in &row_keys {
                result.push(match k {
                    1 => 'L',
                    2 => 'M',
                    3 => 'R',
                    _ => unreachable!(),
                });
            }
            result.push(')');
        }
    }
    
    result
}

pub fn text_to_usb(s: &str) -> ChordOutput {
    let outputs = text_to_usb_internal(s);
    match outputs.len() {
        0 => panic!("Empty chord?"),
        1 => outputs[0].clone(),
        _ => ChordOutput::MultipleChord(outputs),
    }
}

fn text_to_usb_internal(s: &str) -> Vec<ChordOutput> {
    let mut result = Vec::new();
    let mut chars = s.chars().peekable();

    while let Some(c1) = chars.next() {
        let c2_opt = chars.peek();
        match (c1, c2_opt) {
            ('\\', Some(_)) => {
                // the unwrap here is safe because c2 is Some.
                // since c2 was only peeked before, it's necessary to call next() to actually consume it.
                let (modifier, key_code) = unmap_char(&chars.next().unwrap().to_string(), false);
                result.push(ChordOutput::SingleChord { modifier, key_code });
            }
            ('<', Some(_)) => {
                let mut content = String::new();
                while let Some(next_char) = chars.next() {
                    if next_char == '>' {
                        break;
                    }
                    content.push(next_char);
                }
                let (mods, char_content) = parse_value_modifiers(&content);
                let shift = mods & 0x22 != 0;
                let (parsed_shift, key_code) = unmap_char(char_content, shift);
                // i'm not sure if the former should be { parsed_shift | mods | 0x20 } or just { mods | 0x20 }
                result.push(ChordOutput::SingleChord { modifier: if shift { mods | 0x20 } else { parsed_shift | mods }, key_code });
            }
            _ => {
                let (modifier, key_code) = unmap_char(&c1.to_string(), false);
                result.push(ChordOutput::SingleChord { modifier, key_code });
            }
        }
    }
    result
}

fn parse_value_modifiers(s: &str) -> (u8, &str) {
    let mut mods = 0u8;
    let mut chars = s.chars();
    
    while let Some(c) = chars.next() {
        match c {
            'C' => mods |= 0x01,
            'S' => mods |= 0x02,
            'A' => mods |= 0x04,
            '4' => mods |= 0x08,
            'R' => {
                match chars.next() {
                    Some('C') => mods |= 0x10,
                    Some('S') => mods |= 0x20,
                    Some('A') => mods |= 0x40,
                    Some('4') => mods |= 0x80,
                    _ => break,
                }
            }
            '-' => {
                return (mods, chars.as_str());
            }
            _ => {
                return (mods, s);
            }
        }
    }
    (mods, "")
}

fn unmap_char(s_raw: &str, shift: bool) -> (u8, u8) {
    let s = if s_raw.len() == 1 { s_raw } else { &("<".to_string() + s_raw + ">") };
    let (shifted, key_code) = {
        let v = USB_HID_UNMAP.get(s);
        v
        }
        .map(|&(shift1, _shift2, code)| {
            match shift1 {
                Shifted::Shifted => (true, code),
                Shifted::Unshifted => (false, code),
                Shifted::ShiftAgnostic => (shift, code),
            }
        })
        .unwrap_or_else(|| panic!("Error: Unknown string: {}", s));

    let modifier: u8 = if shifted { 0x20 } else { 0 };
    (modifier, key_code)
}

fn usb_hid_to_text(shift: bool, n: u8) -> (bool, String) {
    let shift_state = if shift { Shifted::Shifted } else { Shifted::Unshifted };
    
    if let Some((shift_agnostic, value)) = USB_HID_MAP.get(&(shift_state, n)) {
        let output_shift = match shift_agnostic {
            Shifted::ShiftAgnostic => shift,
            Shifted::Shifted => true,
            Shifted::Unshifted => false,
        };
        (output_shift, value.clone())
    } else if let Some((shift_agnostic, value)) = USB_HID_MAP.get(&(Shifted::ShiftAgnostic, n)) {
        let output_shift = match shift_agnostic {
            Shifted::ShiftAgnostic => shift,
            Shifted::Shifted => true,
            Shifted::Unshifted => false,
        };
        (output_shift, value.clone())
    } else {
        (shift, format!("<0x{:02X}>", n))
    }
}

pub fn generate_text_config(config: &TwiddlerConfig) -> Vec<String> {
    let mut result = Vec::new();

    result.push("version 0".to_string());
    result.push(format!("keyRepeat {}", bool_to_int(config.key_repeat)));
    result.push(format!("directKey {}", bool_to_int(config.direct_key)));
    result.push(format!("joystickLeftClick {}", bool_to_int(config.joystick_left_click)));
    result.push(format!("disableBluetooth {}", bool_to_int(config.disable_bluetooth)));
    result.push(format!("stickyNum {}", bool_to_int(config.sticky_num)));
    result.push(format!("stickyShift {}", bool_to_int(config.sticky_shift)));
    result.push(format!("hapticFeedback {}", bool_to_int(config.haptic_feedback)));
    result.push(format!("sleepTimeout {}", config.sleep_timeout));
    result.push(format!("mouseLeftClickAction {}", config.mouse_left_click_action));
    result.push(format!("mouseMiddleClickAction {}", config.mouse_middle_click_action));
    result.push(format!("mouseRightClickAction {}", config.mouse_right_click_action));
    result.push(format!("mouseAccelFactor {}", config.mouse_accel_factor));
    result.push(format!("keyRepeatDelay {}", config.key_repeat_delay));

    for chord in &config.chords {
        // !!!! DIFFERS FROM ORIGINAL !!!!
        // a chord with no output caused a panic in the original (OOOO <0x0> was written but could not be read)
        // so, we filter those out
        if let ChordOutput::SingleChord { key_code, .. } = chord.output {
            if key_code == 0 {
                continue;
            }
        }

        result.push(format!("{} {}", 
            generate_text_for_keys(&chord.keys), 
            render_chord_output(&chord.output)
        ));
    }

    result
}

fn bool_to_int(b: bool) -> i32 {
    if b { 1 } else { 0 }
}

fn render_chord_output(output: &ChordOutput) -> String {
    match output {
        ChordOutput::SingleChord { modifier, key_code } => {
            render_single_chord(*modifier, *key_code)
        },
        ChordOutput::MultipleChordIndex { string_index } => {
            format!("MultipleChordIndex {}", string_index)
        },
        ChordOutput::MultipleChord(chords) => {
            chords.iter()
                .map(|c| match c {
                    ChordOutput::SingleChord { modifier, key_code } => 
                        render_single_chord(*modifier, *key_code),
                    _ => panic!("Nested MultipleChord not supported"),
                })
                .collect::<Vec<_>>()
                .join("")
        },
    }
}

fn render_single_chord(m: u8, c: u8) -> String {
    let mut result = String::new();
    let (shift, c) = usb_hid_to_text(m & 0x22 != 0, c);
    let mods = render_modifiers(m & (if shift { 0xFF } else { 0xDD }));
    let escape = if c == "<" && mods.is_empty() { "\\" } else { "" };
    
    if !mods.is_empty() {
        write!(result, "<{}-", mods).unwrap();
    }
    
    result.push_str(escape);
    
    if !mods.is_empty() && c.starts_with('<') && c.ends_with('>') {
        result.push_str(&c[1..c.len()-1]);
    } else {
        result.push_str(&c);
    }
    
    if !mods.is_empty() {
        result.push('>');
    }
    
    result
}

fn render_modifiers(m: u8) -> String {
    let mut result = String::new();
    if m & 0x01 != 0 { result.push('C'); }
    if m & 0x02 != 0 { result.push('S'); }
    if m & 0x04 != 0 { result.push('A'); }
    if m & 0x08 != 0 { result.push('4'); }
    if m & 0x10 != 0 { result.push_str("RC"); }
    if m & 0x20 != 0 { result.push_str("RS"); }
    if m & 0x40 != 0 { result.push_str("RA"); }
    if m & 0x80 != 0 { result.push_str("R4"); }
    result
}

fn generate_bin_config(config: &TwiddlerConfig) -> Vec<u8> {
    let mut writer = Cursor::new(Vec::new());

    // Write version (only compatible with v5)
    writer.write_u8(5).unwrap();

    // Write flags
    let flags = (if config.key_repeat { 0x01 } else { 0 }) |
                (if config.direct_key { 0x02 } else { 0 }) |
                (if config.joystick_left_click { 0x04 } else { 0 }) |
                (if config.disable_bluetooth { 0x08 } else { 0 }) |
                (if config.sticky_num { 0x10 } else { 0 }) |
                (if config.sticky_shift { 0x80 } else { 0 });
    writer.write_u8(flags).unwrap();
    
    // Write number of chords
    writer.write_u16::<LittleEndian>(config.chords.len() as u16).unwrap();
    
    // Write config values
    writer.write_u16::<LittleEndian>(config.sleep_timeout).unwrap();
    writer.write_u16::<LittleEndian>(config.mouse_left_click_action).unwrap();
    writer.write_u16::<LittleEndian>(config.mouse_middle_click_action).unwrap();
    writer.write_u16::<LittleEndian>(config.mouse_right_click_action).unwrap();
    writer.write_u8(config.mouse_accel_factor).unwrap();
    writer.write_u8(config.key_repeat_delay).unwrap();

    // Write additional flags
    writer.write_u8(0).unwrap();  // flagsB
    writer.write_u8(if config.haptic_feedback { 0x01 } else { 0 }).unwrap();  // flagsC

    // whether to use the same reference index to the multiple key output table for chords with the same output
    const USE_DEDUPE: bool = true;
    let mut string_contents = Vec::new();
    if !USE_DEDUPE {
        // Write chords
        let mut multiple_chord_count = 0;
        for chord in &config.chords {
            write_chord(&mut writer, chord).unwrap();
            if let ChordOutput::MultipleChord(outputs) = &chord.output {
                string_contents.push(outputs.clone());
                writer.write_u8(multiple_chord_count).unwrap();
                multiple_chord_count += 1;
            }
        }
    } else {
        // Collect and deduplicate string contents
        let mut string_indices = Vec::new();
        for chord in &config.chords {
            write_chord(&mut writer, chord).unwrap();
            if let ChordOutput::MultipleChord(outputs) = &chord.output {
                let index = match string_contents.iter().position(|sc| sc == outputs) {
                    Some(index) => {
                        index
                    }
                    None => {
                        string_contents.len()
                    }
                };
                string_indices.push(index);
                string_contents.push(outputs.clone());
                writer.write_u8(index as u8).unwrap();
            }
        }
    }

    // Write string locations
    let base_string_content_location = 16 + 4 * (config.chords.len() as u32) + 4 * (string_contents.len() as u32);
    let mut current_location = base_string_content_location;
    for content in &string_contents {
        writer.write_u32::<LittleEndian>(current_location).unwrap();
        current_location += 2 + 2 * (content.len() as u32);
    }

    // Write string contents
    for content in &string_contents {
        writer.write_u16::<LittleEndian>((2 + 2 * content.len()) as u16).unwrap();
        for output in content {
            write_chord_output(&mut writer, output).unwrap();
        }
    }

    writer.into_inner()
}

fn write_chord<W: WriteBytesExt>(writer: &mut W, chord: &RawChord) -> std::io::Result<()> {
    let keys_int: u16 = chord.keys.iter().fold(0, |acc, &key| acc | (1 << key));
    writer.write_u16::<LittleEndian>(keys_int)?;
    write_chord_output(writer, &chord.output)
}

fn write_chord_output<W: WriteBytesExt>(writer: &mut W, output: &ChordOutput) -> std::io::Result<()> {
    match output {
        ChordOutput::SingleChord { modifier, key_code } => {
            writer.write_u8(*modifier)?;
            writer.write_u8(*key_code)?;
        },
        ChordOutput::MultipleChordIndex { string_index } => {
            writer.write_u8(0xFF)?;
            writer.write_u8(*string_index)?;
        },
        ChordOutput::MultipleChord(_) => {
            writer.write_u8(0xFF)?;
            // the index of the string in the string contents is written outside of this function
        },
    }
    Ok(())
}

fn check_overwrite(old_filename: &str, new_filename: &str) -> std::io::Result<()> {
    let new_path = Path::new(new_filename);
    if new_path.exists() {
        let source_modification_time = fs::metadata(&old_filename)?.modified()?;
        let target_modification_time = fs::metadata(&new_filename)?.modified()?;

        if source_modification_time <= target_modification_time {
            return Err(std::io::Error::new(
                std::io::ErrorKind::AlreadyExists,
                format!("Refusing to overwrite more-recently modified file {:?}", new_filename)
            ));
        }
    }
    Ok(())
}

pub fn txt_to_cfg(filename: &str) -> std::io::Result<String> {
    let contents = fs::read(filename)?;
    // if the file doesn't start with 'version 0\n', error
    if !contents.starts_with(b"version 0\n") {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Text input file not formatted correctly"));
    }

    let new_filename = Path::new(filename).with_extension("cfg");
    match check_overwrite(filename, new_filename.to_str().unwrap()) {
        Ok(_) => {},
        Err(e) => return Err(e),
    }
    let config = read_text_config(std::str::from_utf8(&contents).unwrap());
    fs::write(&new_filename, generate_bin_config(&config))?;
    Ok(new_filename.to_str().unwrap().to_owned())
}

pub fn cfg_to_txt(filename: &str) -> std::io::Result<String> {
    let contents = fs::read(filename)?;
    // if the file starts with 'version 0\n', error
    if contents.starts_with(b"version 0\n") {
        return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Attempting to encode text file as binary"));
    }

    let new_filename = Path::new(filename).with_extension("txt");
    match check_overwrite(filename, new_filename.to_str().unwrap()) {
        Ok(_) => {},
        Err(e) => return Err(e),
    }
    let config = read_config(&contents).unwrap();
    fs::write(&new_filename, generate_text_config(&config).join("\n") + "\n")?;
    Ok(new_filename.to_str().unwrap().to_owned())
}
